{
  int charPresentation=serialMessage.getMessagePayloadByte(offset + 1);
  charPresentation=0x07 & charPresentation;
switch (charPresentation) {
case ENCODING_ASCII:
    logger.debug("NODE {} : Node Name is encoded with standard ASCII codes",this.getNode().getNodeId());
  break;
case ENCODING_EXTENDED_ASCII:
logger.debug("NODE {} : Node Name is encoded with standard and OEM Extended ASCII codes",this.getNode().getNodeId());
break;
case ENCODING_UTF16:
logger.debug("NODE {} : Node Name is encoded with Unicode UTF-16",this.getNode().getNodeId());
break;
default :
logger.error("NODE {} : Node Name encoding is unsupported. Encoding code {}",this.getNode().getNodeId(),charPresentation);
return null;
}
int numBytes=serialMessage.getMessagePayload().length - (offset + 2);
if (numBytes < 0) {
logger.error("NODE {} : Node Name report error in message length ({})",this.getNode().getNodeId(),serialMessage.getMessagePayload().length);
return null;
}
if (numBytes == 0) {
return new String();
}
if (numBytes > MAX_STRING_LENGTH) {
logger.warn("NODE {} : Node Name is too big; maximum is {} characters {}",this.getNode().getNodeId(),MAX_STRING_LENGTH,numBytes);
numBytes=MAX_STRING_LENGTH;
}
for (int c=0; c < numBytes; c++) {
if (serialMessage.getMessagePayloadByte(c + offset + 2) == 0) {
numBytes=c;
logger.debug("NODE {} : Node name string truncated to {} characters",this.getNode().getNodeId(),numBytes);
break;
}
}
byte[] strBuffer=Arrays.copyOfRange(serialMessage.getMessagePayload(),offset + 2,offset + 2 + numBytes);
String response=null;
try {
switch (charPresentation) {
case ENCODING_ASCII:
case ENCODING_EXTENDED_ASCII:
response=new String(strBuffer,"ASCII");
break;
case ENCODING_UTF16:
String sTemp=new String(strBuffer,"UTF-16");
response=new String(sTemp.getBytes("UTF-8"),"UTF-8");
break;
}
}
 catch (UnsupportedEncodingException uee) {
System.out.println("Exception: " + uee);
}
if (response == null) {
return null;
}
return response.replaceAll("\\p{C}","?");
}
