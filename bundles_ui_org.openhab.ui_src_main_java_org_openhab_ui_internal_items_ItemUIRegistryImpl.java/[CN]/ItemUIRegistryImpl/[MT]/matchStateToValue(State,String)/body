{
  boolean matched=false;
  logger.debug("MATCH CHECK: Type is " + state.getClass().toString());
  if (value.startsWith("\"") && value.endsWith("\""))   value=value.substring(1,value.length() - 1);
  if (state instanceof PercentType || state instanceof DecimalType) {
    logger.debug("MATCH CHECK: Decimal: " + state.toString() + " "+ value);
    try {
      if (Double.parseDouble(state.toString()) > Double.parseDouble(value))       matched=true;
    }
 catch (    NumberFormatException e) {
      logger.debug("MATCH CHECK: Decimal format exception: " + e);
    }
  }
 else   if (state instanceof DateTimeType) {
    Calendar val=((DateTimeType)state).getCalendar();
    Calendar now=Calendar.getInstance();
    long secsDif=(now.getTimeInMillis() - val.getTimeInMillis()) / 1000;
    logger.debug("MATCH CHECK: Time: val=" + val.getTimeInMillis() + " now="+ now.getTimeInMillis()+ " dif="+ secsDif+ "s versus "+ value);
    if (secsDif > Integer.parseInt(value))     matched=true;
  }
 else   if (state instanceof OnOffType || state instanceof OpenClosedType || state instanceof UpDownType|| state instanceof StringType|| state instanceof UnDefType) {
    logger.debug("MATCH CHECK: String: " + state.toString() + " "+ value);
    if (value.equalsIgnoreCase(state.toString()))     matched=true;
  }
  logger.debug("MATCH CHECK: Return is " + matched);
  return matched;
}
