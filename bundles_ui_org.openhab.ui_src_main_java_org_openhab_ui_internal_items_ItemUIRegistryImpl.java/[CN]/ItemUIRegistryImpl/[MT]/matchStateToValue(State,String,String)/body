{
  boolean matched=false;
  logger.debug("MATCH CHECK: Type is " + state.getClass().toString());
  if (value.startsWith("\"") && value.endsWith("\""))   value=value.substring(1,value.length() - 1);
  Condition condition=Condition.EQUAL;
  if (matchCondition != null)   condition=Condition.fromString(matchCondition);
  if (state instanceof PercentType || state instanceof DecimalType) {
    logger.debug("MATCH CHECK: Decimal: " + state.toString() + " "+ value);
    try {
switch (condition) {
case EQUAL:
        if (Double.parseDouble(state.toString()) > Double.parseDouble(value))         matched=true;
      break;
case LTE:
    if (Double.parseDouble(state.toString()) <= Double.parseDouble(value))     matched=true;
  break;
case GTE:
if (Double.parseDouble(state.toString()) >= Double.parseDouble(value)) matched=true;
break;
case GREATER:
if (Double.parseDouble(state.toString()) > Double.parseDouble(value)) matched=true;
break;
case LESS:
if (Double.parseDouble(state.toString()) < Double.parseDouble(value)) matched=true;
break;
case NOT:
case NOTEQUAL:
if (Double.parseDouble(state.toString()) != Double.parseDouble(value)) matched=true;
break;
}
}
 catch (NumberFormatException e) {
logger.debug("MATCH CHECK: Decimal format exception: " + e);
}
}
 else if (state instanceof DateTimeType) {
Calendar val=((DateTimeType)state).getCalendar();
Calendar now=Calendar.getInstance();
long secsDif=(now.getTimeInMillis() - val.getTimeInMillis()) / 1000;
logger.debug("MATCH CHECK: Time: val=" + val.getTimeInMillis() + " now="+ now.getTimeInMillis()+ " dif="+ secsDif+ "s versus "+ value);
switch (condition) {
case EQUAL:
if (secsDif > Integer.parseInt(value)) matched=true;
break;
case LTE:
if (secsDif <= Integer.parseInt(value)) matched=true;
break;
case GTE:
if (secsDif >= Integer.parseInt(value)) matched=true;
break;
case GREATER:
if (secsDif > Integer.parseInt(value)) matched=true;
break;
case LESS:
if (secsDif < Integer.parseInt(value)) matched=true;
break;
case NOT:
case NOTEQUAL:
if (secsDif != Integer.parseInt(value)) matched=true;
break;
}
}
 else if (state instanceof OnOffType || state instanceof OpenClosedType || state instanceof UpDownType|| state instanceof StringType|| state instanceof UnDefType) {
logger.debug("MATCH CHECK: String: " + state.toString() + " "+ value);
switch (condition) {
case NOT:
case NOTEQUAL:
if (!value.equalsIgnoreCase(state.toString())) matched=true;
break;
default :
if (value.equalsIgnoreCase(state.toString())) matched=true;
break;
}
}
logger.debug("MATCH CHECK: Return is " + matched);
return matched;
}
