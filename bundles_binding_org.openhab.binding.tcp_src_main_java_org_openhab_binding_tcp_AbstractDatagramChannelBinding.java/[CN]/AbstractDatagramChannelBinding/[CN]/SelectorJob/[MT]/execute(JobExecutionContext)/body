{
  JobDataMap dataMap=context.getJobDetail().getJobDataMap();
  AbstractDatagramChannelBinding theBinding=(AbstractDatagramChannelBinding)dataMap.get("Binding");
  boolean jobDone=false;
  while (!jobDone) {
synchronized (theBinding.selector) {
      try {
        theBinding.selector.selectNow();
      }
 catch (      IOException e) {
      }
    }
    Iterator<SelectionKey> it=theBinding.selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey selKey=(SelectionKey)it.next();
      it.remove();
      if (selKey.isValid()) {
        DatagramChannel theDatagramChannel=(DatagramChannel)selKey.channel();
        AbstractDatagramChannelBinding.Channel theChannel=theBinding.channels.get(theDatagramChannel);
        if (selKey.isReadable()) {
          InetSocketAddress clientAddress=null;
          ByteBuffer readBuffer=ByteBuffer.allocate(maximumBufferSize);
          int numberBytesRead=0;
          boolean error=false;
          if (selKey == theBinding.listenerKey) {
            try {
              clientAddress=(InetSocketAddress)theDatagramChannel.receive(readBuffer);
              logger.debug("Received {} on the listener port from {}",new String(readBuffer.array()),clientAddress);
              numberBytesRead=readBuffer.position();
            }
 catch (            Exception e) {
              error=true;
            }
          }
 else {
            try {
              numberBytesRead=theDatagramChannel.read(readBuffer);
              logger.debug("Received {} bytes ({}) on the channel {}->{}",new Object[]{numberBytesRead,new String(readBuffer.array()),theDatagramChannel.getLocalAddress(),theDatagramChannel.getRemoteAddress()});
            }
 catch (            NotYetConnectedException e) {
              try {
                logger.warn("The channel for {} has no connection pending ({})",theDatagramChannel.getRemoteAddress(),e.getMessage());
              }
 catch (              IOException e1) {
                logger.error("An exception occurred while getting the remote address of channel {} ({})",theDatagramChannel,e1.getMessage());
              }
              error=true;
            }
catch (            IOException e) {
              try {
                logger.warn("The channel for {} has encountered an unknown IO Exception: {}",theDatagramChannel.getRemoteAddress(),e.getMessage());
              }
 catch (              IOException e1) {
                logger.error("An exception occurred while getting the remote address of channel {} ({})",theDatagramChannel,e1.getMessage());
              }
              error=true;
            }
          }
          if (numberBytesRead == -1) {
            try {
              if (selKey != theBinding.listenerKey) {
                theDatagramChannel.close();
              }
            }
 catch (            IOException e) {
              try {
                logger.warn("The channel for {} is closed ({})",theDatagramChannel.getRemoteAddress(),e.getMessage());
              }
 catch (              IOException e1) {
                logger.error("An exception occurred while getting the remote address of channel {} ({})",theDatagramChannel,e1.getMessage());
              }
            }
            error=true;
          }
          if (error) {
            if (selKey != theBinding.listenerKey) {
              Scheduler scheduler=null;
              try {
                scheduler=StdSchedulerFactory.getDefaultScheduler();
              }
 catch (              SchedulerException e1) {
                logger.error("An exception occurred while getting the Quartz scheduler: {}",e1.getMessage());
              }
              JobDataMap map=new JobDataMap();
              map.put("Channel",theChannel);
              map.put("Binding",theBinding);
              JobDetail job=null;
              Trigger trigger=null;
              job=newJob(ReconnectJob.class).withIdentity(Integer.toHexString(hashCode()) + "-Reconnect-" + Long.toString(System.currentTimeMillis()),"AbstractDatagramChannelBinding").usingJobData(map).build();
              trigger=newTrigger().withIdentity(Integer.toHexString(hashCode()) + "-Reconnect-" + Long.toString(System.currentTimeMillis()),"AbstractDatagramChannelBinding").startAt(futureDate(reconnectInterval,IntervalUnit.SECOND)).build();
              try {
                if (job != null && trigger != null && selKey != theBinding.listenerKey) {
                  if (!theChannel.isReconnecting) {
                    theBinding.channels.setAllReconnecting(theDatagramChannel,true);
                    scheduler.scheduleJob(job,trigger);
                  }
                }
              }
 catch (              SchedulerException e) {
                logger.error("An exception occurred while scheduling a job with the Quartz Scheduler {}",e.getMessage());
              }
            }
          }
 else {
            ArrayList<AbstractDatagramChannelBinding.Channel> channelsToServe=new ArrayList<AbstractDatagramChannelBinding.Channel>();
            if (selKey == theBinding.listenerKey) {
              channelsToServe=theBinding.channels.getAll(Direction.IN,clientAddress);
              if (channelsToServe.size() == 0) {
                logger.warn("Received data {} from an undefined remote end {}. We will not process it",new String(readBuffer.array()),clientAddress);
              }
            }
 else {
              channelsToServe=theBinding.channels.getAll(theDatagramChannel);
            }
            if (channelsToServe.size() > 0) {
              readBuffer.flip();
              if (theBinding.channels.isBlocking(theDatagramChannel)) {
                theChannel=theBinding.channels.getBlocking(theDatagramChannel);
                theChannel.buffer=readBuffer;
              }
 else {
                for (                AbstractDatagramChannelBinding.Channel aChannel : channelsToServe) {
                  if (AbstractDatagramChannelBinding.useAddressMask) {
                    aChannel.lastRemote=clientAddress;
                  }
                  logger.debug("Parsing the received buffer {} for channel {}",new String(readBuffer.array()),aChannel);
                  theBinding.parseChanneledBuffer(aChannel,readBuffer);
                }
              }
            }
 else {
              try {
                if (selKey == theBinding.listenerKey) {
                  logger.warn("No channel is active or defined for the data we received from {}. It will be discarded.",clientAddress);
                }
 else {
                  logger.warn("No channel is active or defined for the data we received from {}. It will be discarded.",theDatagramChannel.getRemoteAddress());
                }
              }
 catch (              IOException e) {
                logger.error("An exception occurred while getting the remote address of channel {} ({})",theDatagramChannel,e.getMessage());
              }
            }
          }
        }
 else         if (selKey.isWritable()) {
          AbstractDatagramChannelBinding.WriteBufferElement theElement=null;
          if (selKey == theBinding.listenerKey) {
            Iterator<AbstractDatagramChannelBinding.WriteBufferElement> iterator=theBinding.writeQueue.iterator();
            while (iterator.hasNext()) {
              AbstractDatagramChannelBinding.WriteBufferElement anElement=iterator.next();
              if (anElement.channel.channel.equals(theBinding.listenerChannel)) {
                theElement=anElement;
                break;
              }
            }
          }
          boolean isBlocking=theBinding.channels.isBlocking(theDatagramChannel);
          if (isBlocking) {
          }
 else {
            if (selKey != theBinding.listenerKey) {
              Iterator<AbstractDatagramChannelBinding.WriteBufferElement> iterator=theBinding.writeQueue.iterator();
              while (iterator.hasNext()) {
                AbstractDatagramChannelBinding.WriteBufferElement anElement=iterator.next();
                if (anElement.channel.channel.equals(theDatagramChannel)) {
                  theElement=anElement;
                  break;
                }
              }
            }
            if (theElement != null && theElement.buffer != null) {
              logger.debug("Picked {} from the queue",theElement);
              if (theElement.isBlocking) {
                theElement.channel.isBlocking=true;
              }
              boolean error=false;
              theElement.buffer.rewind();
              if (selKey == theBinding.listenerKey) {
                try {
                  if (AbstractDatagramChannelBinding.useAddressMask && theElement.channel.remote == null) {
                    if (theElement.channel.lastRemote != null) {
                      logger.debug("Sending {} for the masked inbound channel {}:{} to the remote address {}",new Object[]{new String(theElement.buffer.array()),theElement.channel.host,theElement.channel.port,theElement.channel.lastRemote});
                      theBinding.listenerChannel.send(theElement.buffer,theElement.channel.lastRemote);
                    }
 else {
                      logger.warn("I do not know where to send the data {}",new String(theElement.buffer.array()));
                    }
                  }
 else {
                    logger.debug("Sending {} for the inbound channel {}:{} to the remote address {}",new Object[]{new String(theElement.buffer.array()),theElement.channel.host,theElement.channel.port,theElement.channel.remote});
                    theBinding.listenerChannel.send(theElement.buffer,theElement.channel.remote);
                  }
                }
 catch (                IOException e) {
                  if (theElement.channel.lastRemote != null) {
                    logger.error("An exception occurred while sending data to the remote end {} ({})",theElement.channel.lastRemote,e.getMessage());
                  }
 else {
                    logger.error("An exception occurred while sending data to the remote end {} ({})",theElement.channel.remote,e.getMessage());
                  }
                }
              }
 else {
                try {
                  logger.debug("Sending {} for the outbound channel {}:{} to the remote address {}",new Object[]{new String(theElement.buffer.array()),theElement.channel.host,theElement.channel.port,theElement.channel.remote});
                  theDatagramChannel.write(theElement.buffer);
                }
 catch (                NotYetConnectedException e) {
                  logger.warn("The channel for {} has no connection pending ({})",theElement.channel.remote,e.getMessage());
                  error=true;
                }
catch (                ClosedChannelException e) {
                  logger.warn("The channel for {} is closed ({})",theElement.channel.remote,e.getMessage());
                  error=true;
                }
catch (                IOException e) {
                  logger.warn("The channel for {} has encountered an unknown IO Exception: {}",theElement.channel.remote,e.getMessage());
                  error=true;
                }
              }
              if (error) {
                if (selKey != theBinding.listenerKey) {
                  Scheduler scheduler=null;
                  try {
                    scheduler=StdSchedulerFactory.getDefaultScheduler();
                  }
 catch (                  SchedulerException e1) {
                    logger.error("An exception occurred while getting the Quartz scheduler: {}",e1.getMessage());
                  }
                  JobDataMap map=new JobDataMap();
                  map.put("Channel",theElement.channel);
                  map.put("Binding",theBinding);
                  JobDetail job=null;
                  Trigger trigger=null;
                  job=newJob(ReconnectJob.class).withIdentity(Integer.toHexString(hashCode()) + "-Reconnect-" + Long.toString(System.currentTimeMillis()),"AbstractDatagramChannelBinding").usingJobData(map).build();
                  trigger=newTrigger().withIdentity(Integer.toHexString(hashCode()) + "-Reconnect-" + Long.toString(System.currentTimeMillis()),"AbstractDatagramChannelBinding").startAt(futureDate(reconnectInterval,IntervalUnit.SECOND)).build();
                  try {
                    if (job != null && trigger != null && selKey != theBinding.listenerKey) {
                      if (!theElement.channel.isReconnecting) {
                        theBinding.channels.setAllReconnecting(theElement.channel.channel,true);
                        scheduler.scheduleJob(job,trigger);
                      }
                    }
                  }
 catch (                  SchedulerException e) {
                    logger.error("An exception occurred while scheduling a job with the Quartz Scheduler {}",e.getMessage());
                  }
                }
              }
 else {
                if (theElement != null) {
                  theBinding.writeQueue.remove(theElement);
                }
              }
            }
          }
        }
      }
    }
  }
  jobDone=true;
}
