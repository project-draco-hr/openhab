{
  for (  Command aCommand : ((P)provider).getAllCommands(itemName)) {
    String remoteHost=((P)provider).getHost(itemName,aCommand);
    String remotePort=((P)provider).getPortAsString(itemName,aCommand);
    Direction direction=((P)provider).getDirection(itemName,aCommand);
    InetSocketAddress remoteAddress=null;
    if (!(remoteHost.equals("*") || remotePort.equals("*"))) {
      remoteAddress=new InetSocketAddress(remoteHost,Integer.parseInt(remotePort));
    }
    Channel newChannel=null;
    Channel existingChannel=null;
    if (useAddressMask && (remoteHost.equals("*") || remotePort.equals("*"))) {
      newChannel=new Channel(itemName,aCommand,remoteHost,remotePort,((P)provider).getDirection(itemName,aCommand),false,null,false,null);
      existingChannel=channels.get(itemName,aCommand,direction,remoteHost,remotePort);
    }
 else {
      newChannel=new Channel(itemName,aCommand,remoteAddress,((P)provider).getDirection(itemName,aCommand),false,null,false,null);
      existingChannel=channels.get(itemName,aCommand,direction,remoteAddress);
    }
    if (direction == Direction.IN) {
      if (existingChannel == null) {
        boolean assigned=false;
        if (useAddressMask && (remoteHost.equals("*") || remotePort.equals("*"))) {
          logger.warn("When using address masks we will not verify if we are already listening to similar incoming connections");
        }
 else {
          if (channels.contains(itemName,aCommand,Direction.IN,remoteAddress)) {
            logger.warn("We already listen for incoming connections from {} for the given Item/Command",remoteAddress);
          }
 else {
            if (itemShareChannels) {
              Channel firstChannel=channels.getFirstServed(itemName,direction,remoteAddress);
              if (firstChannel != null) {
                newChannel.channel=firstChannel.channel;
                assigned=true;
              }
            }
            if (bindingShareChannels) {
              Channel firstChannel=channels.getFirstServed(direction,remoteAddress);
              if (firstChannel != null) {
                newChannel.channel=firstChannel.channel;
                assigned=true;
              }
            }
            if (directionsShareChannels) {
              Channel firstChannel=channels.getFirstServed(remoteAddress);
              if (firstChannel != null) {
                newChannel.channel=firstChannel.channel;
                assigned=true;
              }
            }
          }
        }
        if (!assigned) {
          newChannel.channel=listenerChannel;
        }
        if (useAddressMask && (remoteHost.equals("*") || remotePort.equals("*"))) {
          logger.info("We will accept data coming from the remote end with mask {}:{}",remoteHost,remotePort);
        }
 else {
          logger.info("We will accept data coming from the remote end {}",remoteAddress);
        }
        logger.debug("Adding {} to the list of channels",newChannel);
        channels.add(newChannel);
      }
    }
 else     if (direction == Direction.OUT) {
      if (useAddressMask && (remoteHost.equals("*") || remotePort.equals("*"))) {
        logger.error("We do not accept outgoing connections for Items that do use address masks");
      }
 else {
        if (existingChannel == null) {
          existingChannel=newChannel;
          channels.add(newChannel);
          logger.debug("Adding {} to the list of channels",newChannel);
        }
        if (existingChannel.channel == null) {
          boolean assigned=false;
          if (itemShareChannels) {
            Channel firstChannel=channels.getFirstServed(itemName,direction,remoteAddress);
            if (firstChannel != null) {
              newChannel.channel=firstChannel.channel;
              assigned=true;
            }
          }
          if (bindingShareChannels) {
            Channel firstChannel=channels.getFirstServed(direction,remoteAddress);
            if (firstChannel != null) {
              newChannel.channel=firstChannel.channel;
              assigned=true;
            }
          }
synchronized (this) {
            if (!assigned || newChannel.channel == null) {
              DatagramChannel newDatagramChannel=null;
              try {
                newDatagramChannel=DatagramChannel.open();
              }
 catch (              IOException e2) {
                logger.error("An exception occurred while opening a channel: {}",e2.getMessage());
              }
              try {
                newDatagramChannel.configureBlocking(false);
              }
 catch (              IOException e) {
                logger.error("An exception occurred while configuring a channel: {}",e.getMessage());
              }
synchronized (selector) {
                selector.wakeup();
                try {
                  newDatagramChannel.register(selector,newDatagramChannel.validOps());
                }
 catch (                ClosedChannelException e1) {
                  logger.error("An exception occurred while registering a selector: {}",e1.getMessage());
                }
              }
              newChannel.channel=newDatagramChannel;
              try {
                newDatagramChannel.connect(remoteAddress);
              }
 catch (              IOException e) {
                logger.error("An exception occurred while connecting a channel: {}",e.getMessage());
              }
            }
 else {
              logger.info("There is already an active channel {} for the remote end {}",existingChannel.channel,existingChannel.remote);
            }
          }
        }
      }
    }
  }
}
