{
  logger.debug("MaxCulSender Received " + data);
  if (data.startsWith("Z")) {
    if (listenMode) {
      listenModeHandler(data);
      return;
    }
    if (BaseMsg.isForUs(data,srcAddr)) {
      MaxCulMsgType msgType=BaseMsg.getMsgType(data);
      if (msgType == MaxCulMsgType.ACK) {
        AckMsg msg=new AckMsg(data);
        if (pendingAckQueue.containsKey(msg.msgCount) && msg.dstAddrStr.compareTo(srcAddr) == 0) {
          SenderQueueItem qi=pendingAckQueue.remove(msg.msgCount);
          if ((qi.msg.dstAddrStr.compareToIgnoreCase(msg.srcAddrStr) == 0) && (qi.msg.srcAddrStr.compareToIgnoreCase(msg.dstAddrStr) == 0)) {
            if (msg.getIsNack()) {
              logger.error("Message was NAK'd, packet lost");
            }
 else             logger.debug("Message " + msg.msgCount + " ACK'd ok!");
          }
        }
 else         logger.info("Got ACK for message " + msg.msgCount + " but it wasn't in the queue");
      }
 else       if (msgType == MaxCulMsgType.TIME_INFO) {
        TimeInfoMsg msg=new TimeInfoMsg(data);
        sendTimeInfo(msg.srcAddrStr,this.tzStr);
      }
 else {
        this.mcbmp.MaxCulMsgReceived(data);
      }
    }
 else     if (BaseMsg.isForUs(data,"000000")) {
switch (BaseMsg.getMsgType(data)) {
case PAIR_PING:
case WALL_THERMOSTAT_CONTROL:
        this.mcbmp.MaxCulMsgReceived(data);
      break;
default :
    logger.debug("Unhandled broadcast message of type " + BaseMsg.getMsgType(data).toString());
  break;
}
}
}
}
