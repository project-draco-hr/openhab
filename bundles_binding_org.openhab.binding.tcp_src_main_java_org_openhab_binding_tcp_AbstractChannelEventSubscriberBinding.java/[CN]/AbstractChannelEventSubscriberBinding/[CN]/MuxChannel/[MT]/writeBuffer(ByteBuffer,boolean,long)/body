{
  if (isFaulty()) {
    logger.info("Nice try. The channel servicing the connection to {} is faulty, I do not service it anymore. Pls check your network setup",(new InetSocketAddress(host,port).toString()));
    IOException TooManyExceptions=new IOException("Faulty Channel");
    throw TooManyExceptions;
  }
 else {
    if (buffer != null) {
      if (!isConnected()) {
        connectUntilFaulty();
      }
      if (!isFaulty()) {
        lock();
        if (isBlockingWriteRead) {
synchronized (this) {
            inBlockingWriteRead=true;
          }
        }
        Scheduler scheduler=null;
        try {
          scheduler=StdSchedulerFactory.getDefaultScheduler();
        }
 catch (        SchedulerException e1) {
          logger.error("An exception occured while getting the Quartz scheduler: {}",e1.getMessage());
        }
        JobDataMap map=new JobDataMap();
        map.put("MuxChannel",this);
        map.put("Buffer",buffer);
        JobDetail job=newJob(WriteJob.class).withIdentity(Integer.toHexString(hashCode()) + "-Write-" + Long.toString(System.currentTimeMillis()),"AbstractChannelEventSubscriberBinding").usingJobData(map).build();
        Trigger trigger=newTrigger().withIdentity(Integer.toHexString(hashCode()) + "-Write-" + Long.toString(System.currentTimeMillis()),"AbstractChannelEventSubscriberBinding").startNow().build();
        try {
          scheduler.scheduleJob(job,trigger);
        }
 catch (        SchedulerException e) {
          logger.error("Error scheduling a write job with the Quartz Scheduler : {}",e.getMessage());
        }
        if (isBlockingWriteRead) {
          long currentElapsedTimeMillis=System.currentTimeMillis();
          while (blockingReadBuffer != null && (System.currentTimeMillis() - currentElapsedTimeMillis) < timeOut) {
            try {
              Thread.sleep(50);
            }
 catch (            InterruptedException e) {
              logger.warn("Exception occured while waiting waiting during a blocking buffer write");
            }
          }
          ByteBuffer responseBuffer=null;
synchronized (this) {
            responseBuffer=blockingReadBuffer;
            blockingReadBuffer=null;
            inBlockingWriteRead=false;
          }
          unlock();
          return responseBuffer;
        }
 else {
          unlock();
          return buffer;
        }
      }
 else {
        IOException TooManyExceptions=new IOException("Faulty Channel");
        throw TooManyExceptions;
      }
    }
 else {
      IllegalArgumentException anException=new IllegalArgumentException("Buffer is null");
      throw anException;
    }
  }
}
