{
  if (selKey.isValid() && selKey.isConnectable()) {
    C networkChannel=(C)selKey.channel();
    boolean success=false;
    try {
      success=finishConnectChannel(networkChannel);
    }
 catch (    NoConnectionPendingException e) {
      logger.warn("{} has no conection pending",networkChannel);
    }
catch (    ClosedChannelException e) {
      reconnectPersistentConnection(networkChannel);
    }
catch (    IOException e) {
      logger.warn("{} has encountered an IO Exception. We close it down",networkChannel);
      selKey.cancel();
      networkChannel.close();
    }
    if (!success || !isConnectedChannel(networkChannel)) {
    }
 else {
      channelTrackers.get(networkChannel).timeOfSocketConnection=System.currentTimeMillis();
    }
  }
  if (selKey.isValid() && selKey.isReadable()) {
    C networkChannel=(C)selKey.channel();
    if (!isConnectedChannel(networkChannel) && !isConnectionPendingChannel(networkChannel)) {
      reconnectPersistentConnection(networkChannel);
    }
 else {
      ByteBuffer readBuffer=ByteBuffer.allocate(maxBufferSize);
      int numberBytesRead=0;
      try {
        numberBytesRead=readChannel(networkChannel,readBuffer);
      }
 catch (      NotYetConnectedException e) {
      }
catch (      PortUnreachableException e) {
        logger.warn("An ICMP Port Unreachable message has been received on the connected channel {}",networkChannel);
      }
catch (      IOException e) {
        logger.warn("{} has encountered an IO Exception. We close it down",networkChannel);
        selKey.cancel();
        networkChannel.close();
      }
      if (numberBytesRead == -1) {
        if (!isConnectedChannel(networkChannel)) {
          reconnectPersistentConnection(networkChannel);
        }
      }
 else {
        if (channelTrackers.get(networkChannel).inBlockingWriteRead == true && findBlockingBuffer(channelTrackers.get(networkChannel).writeQueue) == null) {
          readBuffer.flip();
synchronized (channelTrackers.get(networkChannel)) {
            channelTrackers.get(networkChannel).blockingReadBuffer=readBuffer;
            channelTrackers.get(networkChannel).inBlockingWriteRead=false;
          }
        }
 else {
          BufferElement bufferElement=new BufferElement();
          bufferElement.byteBuffer=readBuffer;
          bufferElement.byteBuffer.flip();
          bufferElement.isBlocking=false;
          channelTrackers.get(networkChannel).readQueue.add(bufferElement);
        }
      }
    }
  }
  if (selKey.isValid() && selKey.isWritable()) {
    C networkChannel=(C)selKey.channel();
    BufferElement bufferElement=null;
    if (!isConnectedChannel(networkChannel) && !isConnectionPendingChannel(networkChannel)) {
      reconnectPersistentConnection(networkChannel);
    }
 else {
      if (channelTrackers.get(networkChannel).inBlockingWriteRead) {
        bufferElement=findBlockingBuffer(channelTrackers.get(networkChannel).writeQueue);
        while (bufferElement == null) {
          bufferElement=findBlockingBuffer(channelTrackers.get(networkChannel).writeQueue);
        }
      }
 else {
        if (!channelTrackers.get(networkChannel).writeQueue.isEmpty()) {
          bufferElement=channelTrackers.get(networkChannel).writeQueue.poll();
        }
      }
      if (bufferElement != null) {
        bufferElement.byteBuffer.rewind();
        if (bufferElement.byteBuffer.limit() > 0) {
          try {
            writeChannel(networkChannel,bufferElement.byteBuffer);
          }
 catch (          NotYetConnectedException e) {
          }
catch (          IOException e) {
            logger.warn("{} has encountered an IO Exception. We close it down",networkChannel);
            selKey.cancel();
            networkChannel.close();
          }
        }
      }
    }
  }
}
