{
  modbusSlaves.clear();
  if (config != null) {
    Enumeration keys=config.keys();
    while (keys.hasMoreElements()) {
      String key=(String)keys.nextElement();
      if ("service.pid".equals(key)) {
        continue;
      }
      Matcher matcher=EXTRACT_MODBUS_CONFIG_PATTERN.matcher(key);
      if (!matcher.matches()) {
        if ("poll".equals(key)) {
          poll=Integer.valueOf((String)config.get(key));
        }
 else {
          logger.debug("given modbus-slave-config-key '" + key + "' does not follow the expected pattern 'poll' or '<slaveId>.<host|port|id|start|length|type>'");
        }
        continue;
      }
      matcher.reset();
      matcher.find();
      String slave=matcher.group(1);
      ModbusSlave modbusSlave=modbusSlaves.get(slave);
      if (modbusSlave == null) {
        modbusSlave=new ModbusSlave(slave);
        modbusSlaves.put(slave,modbusSlave);
      }
      String configKey=matcher.group(2);
      String value=(String)config.get(key);
      if ("host".equals(configKey)) {
        modbusSlave.host=value;
      }
 else       if ("port".equals(configKey)) {
        modbusSlave.port=Integer.valueOf(value);
      }
 else       if ("start".equals(configKey)) {
        modbusSlave.start=Integer.valueOf(value);
      }
 else       if ("length".equals(configKey)) {
        modbusSlave.length=Integer.valueOf(value);
      }
 else       if ("id".equals(configKey)) {
        modbusSlave.id=Integer.valueOf(value);
      }
 else       if ("type".equals(configKey)) {
        if (ArrayUtils.contains(ModbusBindingProvider.SLAVE_DATA_TYPES,value)) {
          modbusSlave.type=value;
        }
 else {
          throw new ConfigurationException(configKey,"the given slave type '" + value + "' is invalid");
        }
      }
 else {
        throw new ConfigurationException(configKey,"the given configKey '" + configKey + "' is unknown");
      }
    }
  }
  for (  ModbusSlave slave : modbusSlaves.values()) {
    slave.connect();
  }
}
