{
  try {
    Boolean _xblockexpression=null;
{
      ArrayList<String> _newArrayList=CollectionLiterals.<String>newArrayList(msg,this.port);
      UrtsiDevice.logger.debug("Writing \'{}\' to serial port {}",_newArrayList);
      final Function1<Object,Boolean> _function=new Function1<Object,Boolean>(){
        public Boolean apply(        final Object it){
          try {
            try {
              final List<Boolean> listenerResult=CollectionLiterals.<Boolean>newArrayList();
              final Procedure1<SerialPortEvent> _function=new Procedure1<SerialPortEvent>(){
                public void apply(                final SerialPortEvent event){
                  int _eventType=event.getEventType();
                  final int _switchValue=_eventType;
                  boolean _matched=false;
                  if (!_matched) {
                    if (Objects.equal(_switchValue,SerialPortEvent.DATA_AVAILABLE)) {
                      _matched=true;
                      StringBuilder _stringBuilder=new StringBuilder();
                      final StringBuilder sb=_stringBuilder;
                      final byte[] readBuffer=ArrayHelper.getByteArray(20);
                      try {
                        boolean _dowhile=false;
                        do {
{
                            int _available=UrtsiDevice.this.inputStream.available();
                            boolean _greaterThan=(_available > 0);
                            boolean _while=_greaterThan;
                            while (_while) {
{
                                final int bytes=UrtsiDevice.this.inputStream.read(readBuffer);
                                String _string=new String(readBuffer,0,bytes);
                                sb.append(_string);
                              }
                              int _available_1=UrtsiDevice.this.inputStream.available();
                              boolean _greaterThan_1=(_available_1 > 0);
                              _while=_greaterThan_1;
                            }
                            try {
                              Thread.sleep(100);
                            }
 catch (                            final Throwable _t) {
                              if (_t instanceof InterruptedException) {
                                final InterruptedException e=(InterruptedException)_t;
                              }
 else {
                                throw Exceptions.sneakyThrow(_t);
                              }
                            }
                          }
                          int _available=UrtsiDevice.this.inputStream.available();
                          boolean _greaterThan=(_available > 0);
                          _dowhile=_greaterThan;
                        }
 while (_dowhile);
                        final String result=sb.toString();
                        boolean _equals=Objects.equal(result,msg);
                        if (_equals) {
                          listenerResult.add(Boolean.valueOf(true));
                        }
                      }
 catch (                      final Throwable _t) {
                        if (_t instanceof IOException) {
                          final IOException e=(IOException)_t;
                          String _message=e.getMessage();
                          ArrayList<String> _newArrayList=CollectionLiterals.<String>newArrayList(UrtsiDevice.this.port,_message);
                          UrtsiDevice.logger.debug("Error receiving data on serial port {}: {}",_newArrayList);
                        }
 else {
                          throw Exceptions.sneakyThrow(_t);
                        }
                      }
                    }
                  }
                }
              }
;
              UrtsiDevice.this.serialPort.addEventListener(new SerialPortEventListener(){
                public void serialEvent(                SerialPortEvent p0){
                  _function.apply(p0);
                }
              }
);
              UrtsiDevice.this.serialPort.notifyOnDataAvailable(true);
              byte[] _bytes=msg.getBytes();
              UrtsiDevice.this.outputStream.write(_bytes);
              UrtsiDevice.this.outputStream.flush();
              long _currentTimeMillis=System.currentTimeMillis();
              final long timeout=(_currentTimeMillis + 1000);
              boolean _and=false;
              boolean _isEmpty=listenerResult.isEmpty();
              if (!_isEmpty) {
                _and=false;
              }
 else {
                long _currentTimeMillis_1=System.currentTimeMillis();
                boolean _lessThan=(_currentTimeMillis_1 < timeout);
                _and=(_isEmpty && _lessThan);
              }
              boolean _while=_and;
              while (_while) {
                Thread.sleep(100);
                boolean _and_1=false;
                boolean _isEmpty_1=listenerResult.isEmpty();
                if (!_isEmpty_1) {
                  _and_1=false;
                }
 else {
                  long _currentTimeMillis_2=System.currentTimeMillis();
                  boolean _lessThan_1=(_currentTimeMillis_2 < timeout);
                  _and_1=(_isEmpty_1 && _lessThan_1);
                }
                _while=_and_1;
              }
              boolean _isEmpty_1=listenerResult.isEmpty();
              return Boolean.valueOf((!_isEmpty_1));
            }
 catch (            final Throwable _t) {
              if (_t instanceof IOException) {
                final IOException e=(IOException)_t;
                String _message=e.getMessage();
                ArrayList<String> _newArrayList=CollectionLiterals.<String>newArrayList(msg,UrtsiDevice.this.port,_message);
                UrtsiDevice.logger.error("Error writing \'{}\' to serial port {}: {}",_newArrayList);
              }
 else {
                throw Exceptions.sneakyThrow(_t);
              }
            }
 finally {
              UrtsiDevice.this.serialPort.removeEventListener();
            }
            return null;
          }
 catch (          Exception _e) {
            throw Exceptions.sneakyThrow(_e);
          }
        }
      }
;
      final Future<Boolean> future=this.threadExecutor.<Boolean>execute(_function);
      Boolean _get=future.get();
      _xblockexpression=(_get);
    }
    return (_xblockexpression).booleanValue();
  }
 catch (  Exception _e) {
    throw Exceptions.sneakyThrow(_e);
  }
}
