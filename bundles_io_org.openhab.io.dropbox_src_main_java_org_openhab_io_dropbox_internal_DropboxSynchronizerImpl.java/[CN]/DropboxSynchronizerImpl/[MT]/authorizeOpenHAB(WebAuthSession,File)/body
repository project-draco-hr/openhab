{
  WebAuthInfo authInfo=session.getAuthInfo();
  RequestTokenPair requestToken=authInfo.requestTokenPair;
  logger.info("################################################################################################");
  logger.info("# Dropbox-Integration: U S E R   I N T E R A C T I O N   R E Q U I R E D !!");
  logger.info("# 1. Open URL '{}'",authInfo.url);
  logger.info("# 2. Allow openHAB to access Dropbox. Note: The given URL is only valid for THE NEXT 5 MINUTES!");
  logger.info("################################################################################################");
  authorizationThreadInterrupted=false;
  int waitedFor=0;
  while (!authorizationThreadInterrupted) {
    try {
      int interval=5000;
      Thread.sleep(interval);
      waitedFor+=interval;
      try {
        session.retrieveWebAccessToken(requestToken);
        authorizationThreadInterrupted=true;
      }
 catch (      DropboxUnlinkedException due) {
      }
    }
 catch (    InterruptedException e) {
    }
    if (waitedFor > 300000) {
      authorizationThreadInterrupted=true;
      logger.info("Authorization timeslot is closed now! Please use OSGi " + "console to restart the Dropbox-Bundle and re-initiate the authorization process!");
    }
  }
  AccessTokenPair accessToken=session.getAccessTokenPair();
  if (!requestToken.equals(accessToken)) {
    logger.debug("Got token pair from Dropbox (key={}, secret={}) -> serialize to file for later use!",accessToken.key,accessToken.secret);
    writeLocalFile(authFile,accessToken.key + FIELD_DELIMITER + accessToken.secret);
  }
 else {
    logger.debug("AccessToken hasn't been updated by Dropbox. This is likely because the authorization timeslot timed out. Thus we didn't write an authfile for later use.");
    accessToken=null;
  }
  return accessToken;
}
